<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>éŸ³éŸ¿é€šä¿¡ã‚·ã‚¹ãƒ†ãƒ  (Final Version - éŸ³è‰²å¤‰æ›´ç‰ˆ)</title>
    <style>
        body {
            font-family: sans-serif;
            padding: 1em;
            margin: 0;
            background-color: #f9f9f9;
        }

        .container {
            max-width: 600px;
            margin: auto;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
        }

        .section {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
            background-color: #fafafa;
        }

        .warning-box {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            padding: 12px;
            border-radius: 5px;
            margin-bottom: 15px;
            font-size: 0.95em;
        }

        button {
            padding: 8px 16px;
            margin: 5px;
            font-size: 1em;
        }

        input[type="text"] {
            padding: 8px;
            font-size: 1em;
            width: calc(100% - 100px);
            /* ãƒœã‚¿ãƒ³åˆ†ã®å¹…ã‚’å¼•ã */
            margin-right: 10px;
            box-sizing: border-box;
        }

        #textResult {
            word-break: break-all;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>éŸ³éŸ¿é€šä¿¡ã‚·ã‚¹ãƒ†ãƒ  (Final Version - éŸ³è‰²å¤‰æ›´ç‰ˆ)</h1>
        <div class="warning-box">
            <strong>æœ€çµ‚çš„ãªä½¿ã„æ–¹:</strong><br>
            ã“ã®ã‚·ã‚¹ãƒ†ãƒ ã¯ã€2ã¤ã®ãƒ‡ãƒã‚¤ã‚¹ï¼ˆPCã¨ã‚¹ãƒãƒ›ãªã©ï¼‰ã§å‹•ä½œã™ã‚‹ã‚ˆã†ã«è¨­è¨ˆã•ã‚Œã¦ã„ã¾ã™ã€‚<br>
            1. <strong>å—ä¿¡å´ãƒ‡ãƒã‚¤ã‚¹</strong>ã§ã€Œå—ä¿¡é–‹å§‹ã€ã‚’æŠ¼ã—ã¾ã™ï¼ˆæœ€åˆã«ãƒã‚¤ã‚¯ã®è¨±å¯ãŒå¿…è¦ã§ã™ï¼‰ã€‚<br>
            2. <strong>é€ä¿¡å´ãƒ‡ãƒã‚¤ã‚¹</strong>ã§ã€Œé€ä¿¡ã€ã‚’æŠ¼ã—ã€å—ä¿¡å´ã®ãƒã‚¤ã‚¯ã«ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ã‚’è¿‘ã¥ã‘ã¦ãã ã•ã„ã€‚
        </div>
        <div class="section">
            <h2>ğŸ“¤ é€ä¿¡å´ (Sender)</h2>
            <input type="text" id="urlInput" value="This Works!" placeholder="é€ä¿¡ã™ã‚‹ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›">
            <button id="sendButton">é€ä¿¡</button>
            <p>ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: <span id="status-tx">å¾…æ©Ÿä¸­</span></p>
        </div>
        <div class="section">
            <h2>ğŸ“¥ å—ä¿¡å´ (Receiver)</h2>
            <button id="listenButton">å—ä¿¡é–‹å§‹</button>
            <button id="resetButton">ãƒªã‚»ãƒƒãƒˆ</button>
            <p>ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: <span id="status-rx">å¾…æ©Ÿä¸­</span></p>
            <p><b>å—ä¿¡ãƒã‚¤ãƒŠãƒª:</b> <span id="binaryResult"></span></p>
            <p><b>å—ä¿¡ãƒ†ã‚­ã‚¹ãƒˆ:</b> <span id="textResult"></span></p>
            <p style="font-size: 0.8em; color: #666; margin-top: 15px;">åŒæœŸãƒ”ãƒ¼ã‚¯: <span id="debug-sync">0.0</span> |
                ãƒ‡ãƒ¼ã‚¿0ãƒ”ãƒ¼ã‚¯: <span id="debug-data0">0.0</span> | ãƒ‡ãƒ¼ã‚¿1ãƒ”ãƒ¼ã‚¯: <span id="debug-data1">0.0</span></p>
        </div>
    </div>

    <script>
        // === Final Version è¨­å®š: å¯è´åŸŸãƒãƒ£ãƒ¼ãƒ— ===
        let SAMPLE_RATE = 48000; // å—ä¿¡å´ã§å‹•çš„ã«ä¸Šæ›¸ãã•ã‚Œã‚‹
        const SYNC_FREQ_START = 2000, SYNC_FREQ_END = 6000, SYNC_DURATION_MS = 200;
        const DATA_FREQ_LOW = 4000, DATA_FREQ_HIGH = 5000;
        const BIT_DURATION_MS = 40, CHAR_PAUSE_MS = 40;
        const SCRIPT_PROCESSOR_SIZE = 4096;
        const CORRELATION_THRESHOLD = 0.7; // æ¤œå‡ºæ„Ÿåº¦ã‚’å°‘ã—ä¸Šã’ãŸ
        const GAIN_VALUE = 5.0; // å…ƒã®éŸ³é‡

        // UIè¦ç´ 
        const sendButton = document.getElementById('sendButton'), urlInput = document.getElementById('urlInput'),
            statusTx = document.getElementById('status-tx'), listenButton = document.getElementById('listenButton'),
            statusRx = document.getElementById('status-rx'), binaryResult = document.getElementById('binaryResult'),
            textResult = document.getElementById('textResult'), debugSync = document.getElementById('debug-sync'),
            debugData0 = document.getElementById('debug-data0'), debugData1 = document.getElementById('debug-data1'),
            resetButton = document.getElementById('resetButton');

        // é€ä¿¡å´ AudioContext (å¿…è¦ã«ãªã£ãŸã¨ãã«åˆæœŸåŒ–)
        let txAudioContext = null;

        // é€ä¿¡å‡¦ç† (AudioContextã®åˆæœŸåŒ–ã¨å†ç”Ÿ) - éŸ³è‰²å¤‰æ›´ & ã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ—è¿½åŠ ç‰ˆ
        async function playChirp(startFreq, endFreq, durationMs) {
            // AudioContextãŒå­˜åœ¨ã—ãªã„ã€ã¾ãŸã¯ä¸­æ–­ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯å†é–‹ã¾ãŸã¯ä½œæˆ
            if (!txAudioContext || txAudioContext.state === 'closed') {
                txAudioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SAMPLE_RATE });
            }
            if (txAudioContext.state === 'suspended') {
                await txAudioContext.resume(); // ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œå¾Œã«å†ç”Ÿå¯èƒ½ã«ã™ã‚‹
            }

            const oscillator = txAudioContext.createOscillator();
            // æ³¢å½¢ã‚’ 'sine' ã‹ã‚‰ 'sawtooth' ã«å¤‰æ›´ -> ã‚ˆã‚Šã€ŒéŸ³ã€ã£ã½ã„
            oscillator.type = 'sawtooth';

            // ã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ—ç”¨ã®GainNode
            const gainNode = txAudioContext.createGain();
            gainNode.gain.value = 0; // åˆæœŸã‚²ã‚¤ãƒ³ã¯0

            // å‘¨æ³¢æ•°ã®ãƒãƒ£ãƒ¼ãƒ—ã‚’è¨­å®š
            oscillator.frequency.setValueAtTime(startFreq, txAudioContext.currentTime);
            oscillator.frequency.linearRampToValueAtTime(endFreq, txAudioContext.currentTime + durationMs / 1000);

            // ã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ—è¨­å®š (ã‚¢ã‚¿ãƒƒã‚¯ã¨ãƒªãƒªãƒ¼ã‚¹)
            const attackTime = 0.01; // ã‚¢ã‚¿ãƒƒã‚¯æ™‚é–“ (ç§’)
            const releaseTime = 0.01; // ãƒªãƒªãƒ¼ã‚¹æ™‚é–“ (ç§’)
            const startTime = txAudioContext.currentTime;
            const endTime = startTime + durationMs / 1000;

            // ã‚¢ã‚¿ãƒƒã‚¯: éŸ³é‡ã‚’0ã‹ã‚‰æœ€å¤§ã¾ã§ã‚¹ãƒ ãƒ¼ã‚ºã«ä¸Šã’ã‚‹
            gainNode.gain.setValueAtTime(0, startTime);
            gainNode.gain.linearRampToValueAtTime(GAIN_VALUE, startTime + attackTime);

            // ãƒ¡ã‚¤ãƒ³éŸ³é‡ (ãƒ”ãƒ¼ã‚¯ç¶­æŒ): ãƒªãƒªãƒ¼ã‚¹ç›´å‰ã¾ã§æœ€å¤§éŸ³é‡
            // gainNode.gain.setValueAtTime(GAIN_VALUE, endTime - releaseTime); // ã“ã‚Œã ã¨ãƒªãƒªãƒ¼ã‚¹ãŒé€”ä¸­ã§å§‹ã¾ã‚‹

            // ãƒªãƒªãƒ¼ã‚¹: éŸ³é‡ã‚’æœ€å¤§ã‹ã‚‰0ã¾ã§ã‚¹ãƒ ãƒ¼ã‚ºã«ä¸‹ã’ã‚‹
            gainNode.gain.setValueAtTime(GAIN_VALUE, endTime - releaseTime);
            gainNode.gain.linearRampToValueAtTime(0, endTime);

            oscillator.connect(gainNode);
            gainNode.connect(txAudioContext.destination);

            oscillator.start();
            oscillator.stop(endTime);

            // Promiseã®è§£æ±ºã‚’ã€éŸ³ãŒå®Œå…¨ã«çµ‚ã‚ã‚‹ã¾ã§å¾…ã¤
            // ãƒªãƒªãƒ¼ã‚¹æ™‚é–“åˆ†ã¨å°‘ã—ä½™è£•ã‚’ã‚‚ãŸã›ã‚‹
            return new Promise(resolve => setTimeout(resolve, durationMs + releaseTime * 1000 + 50));
        }


        sendButton.onclick = async () => {
            if (sendButton.disabled) return; // é€£æ‰“é˜²æ­¢

            statusTx.textContent = 'é€ä¿¡ä¸­...';
            sendButton.disabled = true;

            try {
                console.log('é€ä¿¡: åŒæœŸä¿¡å· (2-6kHz)');
                await playChirp(SYNC_FREQ_START, SYNC_FREQ_END, SYNC_DURATION_MS);

                const textToSend = urlInput.value;
                const binaryChars = textToSend.split('').map(char => ('0'.repeat(8) + char.charCodeAt(0).toString(2)).slice(-8));

                for (const charBits of binaryChars) {
                    for (const bit of charBits) {
                        if (bit === '0') {
                            await playChirp(DATA_FREQ_HIGH, DATA_FREQ_LOW, BIT_DURATION_MS);
                        } else {
                            await playChirp(DATA_FREQ_LOW, DATA_FREQ_HIGH, BIT_DURATION_MS);
                        }
                    }
                    await new Promise(resolve => setTimeout(resolve, CHAR_PAUSE_MS));
                }
                statusTx.textContent = 'é€ä¿¡å®Œäº†';
            } catch (e) {
                console.error("é€ä¿¡ä¸­ã«ã‚¨ãƒ©ãƒ¼:", e);
                statusTx.textContent = 'é€ä¿¡ã‚¨ãƒ©ãƒ¼';
            } finally {
                sendButton.disabled = false;
            }
        };

        // === å—ä¿¡å´ãƒ­ã‚¸ãƒƒã‚¯ ===
        let rxAudioContext = null, microphoneStream = null, isListening = false, receiveState = 'IDLE',
            syncTemplate, data0Template, data1Template, scriptProcessor, continuousInputBuffer;

        // ãƒãƒ£ãƒ¼ãƒ—ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”Ÿæˆé–¢æ•°
        function generateChirpTemplate(sampleRate, startFreq, endFreq, durationMs) {
            const durationSec = durationMs / 1000;
            const bufferSize = Math.ceil(sampleRate * durationSec);
            const buffer = new Float32Array(bufferSize);
            for (let i = 0; i < bufferSize; i++) {
                const t = i / sampleRate;
                // ãƒãƒ£ãƒ¼ãƒ—ä¿¡å·ã®ä½ç›¸ã‚’è¨ˆç®— (ç·šå½¢ãƒãƒ£ãƒ¼ãƒ—)
                const phase = 2 * Math.PI * (startFreq * t + (endFreq - startFreq) * t * t / (2 * durationSec));
                buffer[i] = Math.sin(phase); // ã“ã‚Œã¯ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãªã®ã§ã€ç›¸é–¢è¨ˆç®—ç”¨ã«ã¯æ­£å¼¦æ³¢ã®ã¾ã¾ã§ã‚‚å•é¡Œãªã„
            }
            return buffer;
        }

        // æ­£è¦åŒ–ç›¸äº’ç›¸é–¢é–¢æ•°
        function normalizedCrossCorrelation(signal, template) {
            let maxCorr = 0;
            const n = signal.length, m = template.length;
            if (n < m) return 0;

            // ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®å¹³å‡ã¨æ¨™æº–åå·®ã‚’è¨ˆç®—
            const templateMean = template.reduce((a, b) => a + b) / m;
            const templateVariance = template.reduce((sum, val) => sum + Math.pow(val - templateMean, 2), 0);
            const templateStdDev = Math.sqrt(templateVariance);
            if (templateStdDev === 0) return 0;

            // ä¿¡å·ã®ã‚¹ãƒ©ã‚¤ãƒ‡ã‚£ãƒ³ã‚°ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã§ç›¸é–¢ã‚’è¨ˆç®—
            for (let i = 0; i <= n - m; i++) {
                const subSignal = signal.slice(i, i + m);
                const subSignalMean = subSignal.reduce((a, b) => a + b) / m;
                const subSignalVariance = subSignal.reduce((sum, val) => sum + Math.pow(val - subSignalMean, 2), 0);
                const subSignalStdDev = Math.sqrt(subSignalVariance);

                if (subSignalStdDev === 0) continue; // ã‚¼ãƒ­é™¤ç®—é˜²æ­¢

                let sumProduct = 0;
                for (let j = 0; j < m; j++) {
                    sumProduct += (subSignal[j] - subSignalMean) * (template[j] - templateMean);
                }
                const corr = sumProduct / (templateStdDev * subSignalStdDev);
                maxCorr = Math.max(maxCorr, corr);
            }
            return maxCorr;
        }

        // å—ä¿¡ãƒ‡ãƒ¼ã‚¿ä¿æŒç”¨å¤‰æ•°
        let receivedBinary = '', nextBitTime = 0, receivedText = '', lastSyncTime = 0;

        // éŸ³å£°å‡¦ç† (ScriptProcessorNodeã§å‘¼ã°ã‚Œã‚‹) - ã“ã®éƒ¨åˆ†ã¯å¤‰æ›´ãªã—
        function processAudio(event) {
            if (!isListening) return;

            const inputData = event.inputBuffer.getChannelData(0);
            const now = rxAudioContext.currentTime;

            // å…¥åŠ›ãƒãƒƒãƒ•ã‚¡ã‚’æ›´æ–° (å¤ã„ãƒ‡ãƒ¼ã‚¿ã‚’æ¨ã¦ã¦æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ )
            const newBuffer = new Float32Array(continuousInputBuffer.length);
            newBuffer.set(continuousInputBuffer.slice(inputData.length));
            newBuffer.set(inputData, continuousInputBuffer.length - inputData.length);
            continuousInputBuffer = newBuffer;

            if (receiveState === 'IDLE') {
                // åŒæœŸä¿¡å·ã®æ¤œå‡º
                const correlation = normalizedCrossCorrelation(continuousInputBuffer, syncTemplate);
                debugSync.textContent = correlation.toFixed(4);

                if (correlation > CORRELATION_THRESHOLD && (now - lastSyncTime) > 1.0) {
                    lastSyncTime = now;
                    console.log(`%cåŒæœŸä¿¡å·æ¤œå‡ºï¼ç›¸é–¢ãƒ”ãƒ¼ã‚¯: ${correlation.toFixed(4)}`, 'color: green; font-weight: bold;');
                    statusRx.textContent = 'ãƒ‡ãƒ¼ã‚¿å—ä¿¡ä¸­...';
                    receiveState = 'RECEIVING';
                    receivedBinary = '';
                    binaryResult.textContent = '';
                    receivedText = '';
                    textResult.textContent = '';
                    // æ¬¡ã®ãƒ“ãƒƒãƒˆã‚’å—ä¿¡ã™ã‚‹äºˆå®šæ™‚åˆ»ã‚’è¨ˆç®—
                    nextBitTime = now + (SYNC_DURATION_MS / 1000) + (BIT_DURATION_MS / 1000) / 2; // åŠãƒ“ãƒƒãƒˆåˆ†ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¿½åŠ 
                }
            } else if (receiveState === 'RECEIVING') {
                // æ¬¡ã®ãƒ“ãƒƒãƒˆã®å—ä¿¡äºˆå®šæ™‚åˆ»ã«ãªã£ãŸã‚‰å‡¦ç†
                if (now >= nextBitTime) {
                    const analysisStartIndex = Math.max(0, continuousInputBuffer.length - data0Template.length * 2); // å°‘ã—ä½™è£•ã‚’æŒãŸã›ã‚‹
                    const analysisBuffer = continuousInputBuffer.slice(analysisStartIndex, analysisStartIndex + data0Template.length * 2);

                    // æœ€ã‚‚ç›¸é–¢ãŒé«˜ã„ä½ç½®ã‚’æ¢ã™ (ç°¡æ˜“çš„ãªã‚¿ã‚¤ãƒŸãƒ³ã‚°åŒæœŸ)
                    let bestCorr0 = 0, bestCorr1 = 0;
                    for (let offset = 0; offset <= analysisBuffer.length - data0Template.length; offset++) {
                        const subBuffer = analysisBuffer.slice(offset, offset + data0Template.length);
                        const corr0 = normalizedCrossCorrelation(subBuffer, data0Template);
                        const corr1 = normalizedCrossCorrelation(subBuffer, data1Template);
                        if (corr0 > bestCorr0) bestCorr0 = corr0;
                        if (corr1 > bestCorr1) bestCorr1 = corr1;
                    }

                    debugData0.textContent = bestCorr0.toFixed(4);
                    debugData1.textContent = bestCorr1.toFixed(4);

                    const bit = bestCorr0 > bestCorr1 ? '0' : '1';
                    console.log(`ãƒ“ãƒƒãƒˆæ¤œå‡º: ${bit} (Corr0: ${bestCorr0.toFixed(3)}, Corr1: ${bestCorr1.toFixed(3)})`);
                    receivedBinary += bit;
                    binaryResult.textContent = receivedBinary;

                    if (receivedBinary.length % 8 === 0) {
                        const char = String.fromCharCode(parseInt(receivedBinary.slice(-8), 2));
                        receivedText += char;
                        textResult.textContent = receivedText;
                        console.log(`%cæ–‡å­—å—ä¿¡: "${char}"`, 'color: blue; font-weight: bold;');
                        // æ¬¡ã®æ–‡å­—ã®æœ€åˆã®ãƒ“ãƒƒãƒˆã®æ™‚é–“
                        nextBitTime += (BIT_DURATION_MS + CHAR_PAUSE_MS) / 1000;
                    } else {
                        // æ¬¡ã®ãƒ“ãƒƒãƒˆã®æ™‚é–“
                        nextBitTime += BIT_DURATION_MS / 1000;
                    }

                    // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå‡¦ç† (åŒæœŸå¾Œ5ç§’ã§ãƒªã‚»ãƒƒãƒˆ)
                    if (now - lastSyncTime > 5) {
                        console.log("å—ä¿¡ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ");
                        resetButton.onclick();
                    }
                }
            }
        }

        // å—ä¿¡é–‹å§‹å‡¦ç† - ã“ã®éƒ¨åˆ†ã¯å¤‰æ›´ãªã—
        async function startListening() {
            if (isListening) return;
            statusRx.textContent = 'ãƒã‚¤ã‚¯æº–å‚™ä¸­...';

            try {
                // ãƒã‚¤ã‚¯ã®åˆ¶ç´„ (ã‚¨ã‚³ãƒ¼ã‚­ãƒ£ãƒ³ã‚»ãƒ©ãªã©ã‚’ç„¡åŠ¹åŒ–)
                const constraints = {
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false,
                        // sampleRate: 48000 // æŒ‡å®šã—ãªã„ã“ã¨ã§ãƒ‡ãƒã‚¤ã‚¹ã®ãƒã‚¤ãƒ†ã‚£ãƒ–ãƒ¬ãƒ¼ãƒˆã‚’ä½¿ç”¨
                    },
                    video: false
                };
                microphoneStream = await navigator.mediaDevices.getUserMedia(constraints);

                // å—ä¿¡å´AudioContextã®ä½œæˆ (ãƒã‚¤ã‚¯å–å¾—å¾Œã«ä½œæˆ)
                rxAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                SAMPLE_RATE = rxAudioContext.sampleRate; // å®Ÿéš›ã®ã‚µãƒ³ãƒ—ãƒ«ãƒ¬ãƒ¼ãƒˆã‚’å–å¾—
                console.log(`%cå®Ÿéš›ã®ã‚µãƒ³ãƒ—ãƒ«ãƒ¬ãƒ¼ãƒˆ: ${SAMPLE_RATE} Hz`, 'color: blue; font-size: 1.1em;');

                // å„ãƒãƒ£ãƒ¼ãƒ—ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ç”Ÿæˆ (ã‚µãƒ³ãƒ—ãƒ«ãƒ¬ãƒ¼ãƒˆã«åˆã‚ã›ã¦)
                // ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã¯ç›¸é–¢è¨ˆç®—ç”¨ãªã®ã§ã€æ­£å¼¦æ³¢ã®ã¾ã¾ã§ã‚‚å•é¡Œãªã„
                syncTemplate = generateChirpTemplate(SAMPLE_RATE, SYNC_FREQ_START, SYNC_FREQ_END, SYNC_DURATION_MS);
                data0Template = generateChirpTemplate(SAMPLE_RATE, DATA_FREQ_HIGH, DATA_FREQ_LOW, BIT_DURATION_MS);
                data1Template = generateChirpTemplate(SAMPLE_RATE, DATA_FREQ_LOW, DATA_FREQ_HIGH, BIT_DURATION_MS);

                // å…¥åŠ›ãƒãƒƒãƒ•ã‚¡ã®åˆæœŸåŒ–
                continuousInputBuffer = new Float32Array(SCRIPT_PROCESSOR_SIZE * 2);

                // ãƒã‚¤ã‚¯ -> Gain -> ScriptProcessor -> å‡¦ç†
                const source = rxAudioContext.createMediaStreamSource(microphoneStream);
                const gainNode = rxAudioContext.createGain();
                gainNode.gain.value = GAIN_VALUE;
                scriptProcessor = rxAudioContext.createScriptProcessor(SCRIPT_PROCESSOR_SIZE, 1, 1);
                scriptProcessor.onaudioprocess = processAudio;

                source.connect(gainNode);
                gainNode.connect(scriptProcessor);

                isListening = true;
                listenButton.textContent = 'å—ä¿¡åœæ­¢';
                statusRx.textContent = 'åŒæœŸä¿¡å·å¾…æ©Ÿä¸­...';
                console.log('å—ä¿¡é–‹å§‹ã€åŒæœŸä¿¡å·ã‚’å¾…ã£ã¦ã„ã¾ã™...');
            } catch (err) {
                console.error("ãƒã‚¤ã‚¯ã®èµ·å‹•ã«å¤±æ•—:", err);
                statusRx.textContent = `ãƒã‚¤ã‚¯ã‚¨ãƒ©ãƒ¼: ${err.message || 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼'}`;
                // ä¸€æ™‚çš„ãªã‚¨ãƒ©ãƒ¼ã§ã‚‚ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ã§å†è©¦è¡Œã§ãã‚‹ã‚ˆã†ã«ã—ã¦ãŠã
            }
        }

        // å—ä¿¡åœæ­¢å‡¦ç† - ã“ã®éƒ¨åˆ†ã¯å¤‰æ›´ãªã—
        function stopListening() {
            if (!isListening) return;
            isListening = false;
            if (microphoneStream) {
                microphoneStream.getTracks().forEach(track => track.stop());
            }
            if (scriptProcessor) {
                scriptProcessor.disconnect();
            }
            if (rxAudioContext) {
                rxAudioContext.close().catch(e => console.error("AudioContextã‚¯ãƒ­ãƒ¼ã‚ºã‚¨ãƒ©ãƒ¼:", e));
            }
            listenButton.textContent = 'å—ä¿¡é–‹å§‹';
            statusRx.textContent = 'åœæ­¢ä¸­';
            console.log('å—ä¿¡åœæ­¢');
        }

        // ãƒªã‚»ãƒƒãƒˆå‡¦ç† - ã“ã®éƒ¨åˆ†ã¯å¤‰æ›´ãªã—
        resetButton.onclick = () => {
            receiveState = 'IDLE';
            receivedBinary = '';
            binaryResult.textContent = '';
            receivedText = '';
            textResult.textContent = '';
            statusRx.textContent = isListening ? 'åŒæœŸä¿¡å·å¾…æ©Ÿä¸­...' : 'ãƒªã‚»ãƒƒãƒˆå®Œäº†';
            console.log('å—ä¿¡çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸã€‚');
        };

        // å—ä¿¡é–‹å§‹/åœæ­¢ãƒœã‚¿ãƒ³ã®ãƒˆã‚°ãƒ« - ã“ã®éƒ¨åˆ†ã¯å¤‰æ›´ãªã—
        listenButton.onclick = () => isListening ? stopListening() : startListening();

    </script>
</body>

</html>